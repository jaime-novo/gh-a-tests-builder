#!/bin/bash

# This script is used to generate a JSON file with the information of the services that have been updated in the
# production environment.
# The script is executed by the CI pipeline, and it is triggered by a push to the main branch.

# Use the helpers.sh scritp to access the get_git_root function
readonly script_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly updated_services_dir="/tmp/json_updated_services"
source "$script_path/helpers.sh"

# This function iterates through the list of the JSON files generated by the overall process to send the notifications
# to the Slack Webhook URL. Since this approach does not use Block Kit, each message has to be sent individually, which
# may be a bit spammy if there are many services to notify.
function send_notifications {

  # Use 'find' to get a list of files in the directory
  files=$(find "$updated_services_dir" -type f)

  # Iterate through the list of files using a 'for' loop
  for file in $files; do
    json_payload=$(cat "$file")
    curl -X POST -H "Content-type: application/json" --data "$json_payload" "${SLACK_WEBHOOK_URL}"
  done
}

# Function used to write a JSON file in a given path with the payload for a specific service and that must be sent to
# Slack through the Webhook URL.
function generate_notification_file {
  local -r service_name="$1"
  local -r region_name="$2"
  local -r old_version="$3"
  local -r new_version="$4"

  # Remove the prefix (Separated by a dash) - Update/Remove this regex if no prefix are used in the future
  local -r old_version_sha=$(echo "$old_version" | sed -E 's/^[^-]+-//')
  local -r new_version_sha=$(echo "$new_version" | sed -E 's/^[^-]+-//')

  json_file="$updated_services_dir/${service_name}.json"

  # Assume that the approved PR was applied in all regions, therefore, we only care about a single region
  # to notify about the deployment update
  if [[ ! -f "$json_file" ]]; then
    payload="{
      \"service_name\": \"$service_name\",
      \"old_version\": \"$old_version\",
      \"new_version\": \"$new_version\",
      \"commit_url\": \"${COMMIT_URL}\"
    }"

    echo "Writing $json_file"
    echo "$payload" > "$json_file"
  fi
}

# Function used to retrieve the list of ms_config.yaml files modified in the current PR, and then, generate a JSON file
# to report the version update of the service.
function generate_service_update_list {
  # Generate/update the file with the actual content to notify
  local -r artifact_config="$1"

  echo "Generating service update list with $artifact_config"

  full_path=$(get_git_root)/$artifact_config

  # Retrieve core service information
  local -r service_name="$(${YQ_PATH}/yq 'keys | .[]' "$full_path" | head -n1)"
  local -r region=$(echo "$artifact_config" | awk -F'/' '{print $2}')

  # Although not as generic, the insterest lies in prod deployment, hence the hardcoded value
  current_version="$(${YQ_PATH}/yq ".$service_name.prod.image-tag" "$full_path")"
  previous_version="none"

  if [[ -f "$(get_git_root)/${PREVIOUS_COMMIT_PATH}/$artifact_config" ]]; then
    previous_version="$(${YQ_PATH}/yq ".$service_name.prod.image-tag" "$(get_git_root)/${PREVIOUS_COMMIT_PATH}/$artifact_config")"
  fi

  generate_notification_file "$service_name" "$region" "$previous_version" "$current_version"
}

# Function thar collects all the updated modules under the services directory, to check if there was a version change
# or an infrastructure update (The former is the one used to report service updates)
function handle_updated_artifacts {
  local -r source_ref="$1"
  local -r ref="$2"

  # Get the list of updated modules whose YAML files have changed
  echo "Retrieving the list of updated services..."
  updated_files="$(
    git-updated-files --source-ref "$source_ref" --target-ref "$ref" --ext ms_config.yaml --exclude-ext artifacts-configs.yaml \
      | (grep -E '^prod/.*/prod/services/' || true)
    )"
  
  # Run plan or apply on modified modules.
  if [[ -z "$updated_files" ]]; then
    echo "No services artifacts were updated."
    exit 0
  else
    echo "The following artifact definition files were updated:"
    echo "$updated_files"
    
    echo "$updated_files" \
      | xargs -r -I{} -n1 bash -c "set -o pipefail -e; generate_service_update_list {}"
  fi
}

function run {
  local -r source_ref="$1"
  local -r ref="$2"

  export updated_services_dir

  export -f generate_service_update_list
  export -f get_git_root
  export -f generate_notification_file

  # We use a Helper dir to send several notifications if needed
  mkdir -p $updated_services_dir

  handle_updated_artifacts "$source_ref" "$ref"
  send_notifications
}

run "$@"